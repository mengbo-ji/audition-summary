### 自我介绍

## 项目用到的技术

#### 项目

- 采用dva的包和 团队内部构建器自己搭建项目

#### 技术栈

- 日常开发：react + ts + hooks + bizCharts等
- 对内项目：vite

#### 工程化

> 开发 - 构建 - 部署 一整套规范流程

- 开发
  - 分支命名规范：feature、fix等明明
  - 代码风格统一：成熟的eslint、styleLint自动化配置方案
  - 技术栈统一：全部采用react + ts + hooks的方式，二维图表采用bizCharts，微前端采用ConsoleOS
- 构建
  - 打包构建统一：团队有适合自己的内部构建器，可支持 私有云 公有云等的构建发布任务
  - 统一的云构建 中间平台
- 部署
  - cdn部署

## 对vue了解吗

- 了解不多，mvvm框架，双向数据流

## var let const

#### 共同点

- 都可以用来声明变量

#### 不同点

- var 声明的变量会默认挂在到window上，而let 和 const 不会
- var 声明的变量存在变量提升，这是因为var声明的变量在变量环境中，在编译阶段会被赋值默认值，而let 和 const存在词法环境中，在编译阶段不会赋值默认值，所以存在暂时性死区这个概念
- let 和 const 都es6新增的，都可以声明变量
- let 和 const声明变量不可以重复声明，不可以提前使用
- const 代表常量的意思，一般用来声明不会改变的变量，当然引用类型还是会改变的，只是不能重新赋值

## this指向和改变this指向的方法

#### this指向

- 我们可以单纯的理解为 谁调用this 那就指向谁

#### 改变this指向的方法

> call apply bind

- 共同点：都可以改变this的指向，第一个参数都是要指向的this
- 不同点
  - call和apply返回的是函数调用的结果，而bind返回的是函数体
  - call和bind的第二个参数就是传入函数的参数，apply第二个参数是一个数组，数组中每一项才是传入函数的参数

## Vue组件是怎样传参的

- 不了解

#### react

- 组件props的形式传参

## react 生命周期

#### 类组件

- 用的不多

### hooks

- hooks本身就是函数，更优雅的复用

- 函数式组件的心智模型更加“声明式”。

- hooks（主要是useEffect）取代了生命周期的概念（减少API），让开发者的代码更加“声明化”：

  - 新的思维：“我的组件有xxx这个副作用，这个副作用依赖的数据是props.A和state.B”。从过去的**命令式**转变成了**声明式**编程。
  - 其实仔细想一想，人们过去使用生命周期不就是为了判断执行副作用的时机吗？**现在hooks直接给你一个声明副作用的API，使得生命周期变成了一个“底层概念”，无需开发者考虑。开发者工作在更高的抽象层次上了。**

- 践行 代数效应 view=fn（state）

  > 纯函数，将副作用从函数中剥离出去，我们只需要关注输入和输出.

- 函数更灵活，更易拆分，更易测试

- 最主要是 马上要出的react18 并发模式

  - react出了很多 对应的hook 来为并发模式做准备，例如：suspense useDeferredValue
  - 而 hooks 是最能发挥并发模式的最好方式

## react-router标签含义

#### Router

- 外层最大的标签，包裹整个路由

#### Route

- 每个路由对应一个route
- path exact component render等

#### Switch

- 匹配唯一

#### Redirect

- 重定向 from to

#### hooks

- useHistory
- useLoaction
- useParams
- useRouteMatch

## react合成事件

#### 特点

- 事件委托的形式

- React自己实现了一套高效的事件注册，存储，分发和重用逻辑，最大化的解决了很多浏览器兼容问题
- 所有组件的时间都会挂在到document上 react17以后是挂在到根节点root上
- 使用对象池管理合成事件的 创建和销毁

## react组件更新的整个过程

- 调用 ReactDom.render 、this.setState、this.forceUpdate、useState的返回的回调函数（dispatchAction）触发更新
- 调用类组件的render方法或者函数组件本身，获取return 之后新的jsx
- 调度器scheduler根据不同更新不同的优先级 选出优先级最高的更新进入协调器reconciler
- 协调器reconciler 对比两颗 fiber树，找到不同，然后打上对应的标记，Placement、Update、Deletion

> 上面这一步 随时会由于 浏览器空闲时间不够或者有更高优先级的事件发生而中断

- 标记打完之后 交给渲染器renderer，渲染器根据不同的标记 作出不同的dom操作

## MVVM

#### 概念

- MVVM 可以写成 MV-VM，是 Model View - ViewModel 的缩写，可以算是 MVP 模式的变种，View 和 Model 职责和 MVP 相同，但 ViewModel 主要靠 DataBinding 把 View 和 Model 做了自动关联，框架替应用开发者实现数据变化后的视图更新，相当于简化了 Presenter 的部分功能

  > 前端比较熟悉的 Vue 正是使用 MVVM 模式，使用 Vue 实现示例功能

- 在 View 中做了数据和视图的绑定，在 ViewModel 中只需要更新数据，视图就会自动变化，DataBinding 由框架实现

## 设计模式

#### 概念

1. 发布-订阅
2. 一对多，一个被观察者，多个观察者
3. 优点：支持广播，解耦性强
4. 缺点：大量观察者，广播有性能问题

#### 应用场景

1. vue的数据绑定 就是利用了观察者模式

   ![img](https://img2018.cnblogs.com/blog/1492200/201810/1492200-20181023200852131-291342969.png)

2. js事件绑定 也是观察者模式

## leader 如何搞定这个项目

1. 第一步 产品、前后端、测试同学 大家需求评审完毕

2. 第二步 技术评审+排期，在这步之前其实需求评审的结果基本可以作出用什么技术架构的判断了，排期这块，要根据实际项目的紧急度。和目前团队的实际情况，人员配置、手头工作量等
3. 确定排期、确定技术架构、确定人员 就开始全力开发了
4. 现在基本都是 前后端分离的年代了，所以前端同学 可以做一些前期的准备，比如公共模块的抽离、方法的复用。针对一些评审时 觉得难的一些地方提前调研，避免后期影响到项目的上线
5. 开发完毕之后，前后端联调完毕、提测结束、上线。